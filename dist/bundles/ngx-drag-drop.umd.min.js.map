{"version":3,"sources":["ng://ngx-drag-drop/dnd-utils.ts","ng://ngx-drag-drop/dnd-state.ts","ng://ngx-drag-drop/dnd-draggable.directive.ts","ng://ngx-drag-drop/dnd-dropzone.directive.ts","ng://ngx-drag-drop/dnd-handle.directive.ts","ng://ngx-drag-drop/dnd.module.ts"],"names":["DROP_EFFECTS","CUSTOM_MIME_TYPE","JSON_MIME_TYPE","MSIE_MIME_TYPE","mimeTypeIsCustom","mimeType","substr","length","getWellKnownMimeType","event","dataTransfer","types","i","filterEffects","effects","allowed","filter","effect","toLowerCase","indexOf","calculateDragImageOffset","dragImage","dragImageComputedStyle","window","getComputedStyle","paddingTop","parseFloat","paddingLeft","borderTop","borderTopWidth","borderLeft","borderLeftWidth","x","offsetX","y","offsetY","_dndState","isDragging","dropEffect","effectAllowed","type","undefined","endDrag","setDropEffect","getDropEffect","dataTransferEffectAllowed","ctrlKey","altKey","getDndType","isExternalDrag","dndState","DndDragImageRefDirective","parent","elementRef","registerDragImage","Directive","args","selector","DndDraggableDirective","ElementRef","renderer","ngZone","_this","this","dndEffectAllowed","dndDraggingClass","dndDraggingSourceClass","dndDraggableDisabledClass","dndDragImageOffsetFunction","dndStart","EventEmitter","dndDrag","dndEnd","dndMoved","dndCopied","dndLinked","dndCanceled","draggable","isDragStarted","dragEventHandler","onDrag","Object","defineProperty","prototype","value","removeClass","nativeElement","addClass","dndDisableIf","ngAfterViewInit","addHostListeners","runOutsideAngular","addEventListener","ngOnDestroy","removeEventListener","toggleDragLock","component","force","componentThatLocked","removeHostListeners","onDragStart","dndHandle","_dndUsingHandle","startDrag","dndType","setDragData","data","dataString","JSON","stringify","setData","e","effectsAllowed","dndDraggable","determineDragImage","dndDragImageElementRef","setDragImage","offsetFunction","offset","unregister","listen","emit","onDragEnd","dropEffectEmitter","setTimeout","stopPropagation","registerDragHandle","handle","dragStartListener","bind","dragEndListener","exportAs","Renderer2","NgZone","Input","Output","HostBinding","DndPlaceholderRefDirective","DndDropzoneDirective","dndAllowExternal","dndHorizontal","dndDragoverClass","dndDropzoneDisabledClass","dndDragover","dndDrop","placeholder","disabled","dragEnterEventHandler","onDragEnter","dragOverEventHandler","onDragOver","dragLeaveEventHandler","onDragLeave","tryGetPlaceholder","removePlaceholderFromDOM","_dndDropzoneActive","newTarget","document","elementFromPoint","clientX","clientY","contains","isDropAllowed","preventDefault","cleanupDragoverState","defaultPrevented","checkAndUpdatePlaceholderPosition","onDrop","getDropData","dragIsExternal","parse","getData","dropIndex","getPlaceholderIndex","isExternal","index","dndDropzone","Array","isArray","Error","dndPlaceholderRef","querySelector","parentNode","removeChild","appendChild","directChild","getDirectChildElement","parentElement","childElement","shouldPositionPlaceholderBeforeElement","element","horizontal","bounds","getBoundingClientRect","left","width","top","height","previousSibling","insertBefore","nextSibling","call","children","ContentChild","HostListener","DndHandleDirective","onDragEvent","DndModule","NgModule","imports","CommonModule","declarations","exports"],"mappings":"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","sourcesContent":["import { DropEffect, EffectAllowed } from \"./dnd-types\";\r\n\r\nexport interface DragDropData {\r\n  data?:any;\r\n  type?:string;\r\n}\r\n\r\nexport interface DndEvent extends DragEvent {\r\n  _dndUsingHandle?:boolean;\r\n  _dndDropzoneActive?:true;\r\n}\r\n\r\nexport type DndDragImageOffsetFunction = ( event:DragEvent, dragImage:Element ) => { x:number, y:number };\r\n\r\nexport const DROP_EFFECTS = [ \"move\", \"copy\", \"link\" ] as DropEffect[];\r\n\r\nexport const CUSTOM_MIME_TYPE = \"application/x-dnd\";\r\nexport const JSON_MIME_TYPE = \"application/json\";\r\nexport const MSIE_MIME_TYPE = \"Text\";\r\n\r\nfunction mimeTypeIsCustom( mimeType:string ) {\r\n\r\n  return mimeType.substr( 0, CUSTOM_MIME_TYPE.length ) === CUSTOM_MIME_TYPE;\r\n}\r\n\r\nexport function getWellKnownMimeType( event:DragEvent ):string | null {\r\n\r\n  if( event.dataTransfer ) {\r\n\r\n    const types = event.dataTransfer.types;\r\n\r\n    // IE 9 workaround.\r\n    if( !types ) {\r\n\r\n      return MSIE_MIME_TYPE;\r\n    }\r\n\r\n    for( let i = 0; i < types.length; i++ ) {\r\n\r\n      if( types[ i ] === MSIE_MIME_TYPE\r\n        || types[ i ] === JSON_MIME_TYPE\r\n        || mimeTypeIsCustom( types[ i ] ) ) {\r\n\r\n        return types[ i ];\r\n      }\r\n    }\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nexport function setDragData( event:DragEvent, data:DragDropData, effectAllowed:EffectAllowed ):void {\r\n\r\n  // Internet Explorer and Microsoft Edge don't support custom mime types, see design doc:\r\n  // https://github.com/marceljuenemann/angular-drag-and-drop-lists/wiki/Data-Transfer-Design\r\n  const mimeType = CUSTOM_MIME_TYPE + (data.type ? (\"-\" + data.type) : \"\");\r\n\r\n  const dataString = JSON.stringify( data );\r\n\r\n  try {\r\n\r\n    event.dataTransfer.setData( mimeType, dataString );\r\n\r\n  }\r\n  catch( e ) {\r\n\r\n    //   Setting a custom MIME type did not work, we are probably in IE or Edge.\r\n    try {\r\n\r\n      event.dataTransfer.setData( JSON_MIME_TYPE, dataString );\r\n\r\n    }\r\n    catch( e ) {\r\n\r\n      //   We are in Internet Explorer and can only use the Text MIME type. Also note that IE\r\n      //   does not allow changing the cursor in the dragover event, therefore we have to choose\r\n      //   the one we want to display now by setting effectAllowed.\r\n      const effectsAllowed = filterEffects( DROP_EFFECTS, effectAllowed );\r\n      event.dataTransfer.effectAllowed = effectsAllowed[ 0 ];\r\n\r\n      event.dataTransfer.setData( MSIE_MIME_TYPE, dataString );\r\n    }\r\n  }\r\n}\r\n\r\nexport function getDropData( event:DragEvent, dragIsExternal:boolean ):DragDropData {\r\n\r\n  // check if the mime type is well known\r\n  const mimeType = getWellKnownMimeType( event );\r\n\r\n  // drag did not originate from [dndDraggable]\r\n  if( dragIsExternal === true ) {\r\n\r\n    if( mimeType !== null\r\n      && mimeTypeIsCustom( mimeType ) ) {\r\n\r\n      // the type of content is well known and safe to handle\r\n      return JSON.parse( event.dataTransfer.getData( mimeType ) );\r\n    }\r\n\r\n    // the contained data is unknown, let user handle it\r\n    return {};\r\n  }\r\n\r\n  // the type of content is well known and safe to handle\r\n  return JSON.parse( event.dataTransfer.getData( mimeType ) );\r\n}\r\n\r\nexport function filterEffects( effects:DropEffect[], allowed:EffectAllowed | DropEffect ):DropEffect[] {\r\n\r\n  if( allowed === \"all\"\r\n    || allowed === \"uninitialized\" ) {\r\n\r\n    return effects;\r\n  }\r\n\r\n  return effects.filter( function( effect ) {\r\n\r\n    return allowed.toLowerCase().indexOf( effect ) !== -1;\r\n  } );\r\n}\r\n\r\nexport function getDirectChildElement( parentElement:Element, childElement:Element ):Element | null {\r\n\r\n  let directChild:Node = childElement;\r\n\r\n  while( directChild.parentNode !== parentElement ) {\r\n\r\n    // reached root node without finding given parent\r\n    if( !directChild.parentNode ) {\r\n\r\n      return null;\r\n    }\r\n\r\n    directChild = directChild.parentNode;\r\n  }\r\n\r\n  return directChild as Element;\r\n}\r\n\r\nexport function shouldPositionPlaceholderBeforeElement( event:DragEvent, element:Element, horizontal:boolean ) {\r\n\r\n  const bounds = element.getBoundingClientRect();\r\n\r\n  // If the pointer is in the upper half of the list item element,\r\n  // we position the placeholder before the list item, otherwise after it.\r\n  if( horizontal ) {\r\n\r\n    return (event.clientX < bounds.left + bounds.width / 2);\r\n  }\r\n\r\n  return (event.clientY < bounds.top + bounds.height / 2);\r\n}\r\n\r\nexport function calculateDragImageOffset( event:DragEvent, dragImage:Element ):{ x:number, y:number } {\r\n\r\n  const dragImageComputedStyle = window.getComputedStyle( dragImage );\r\n  const paddingTop = parseFloat( dragImageComputedStyle.paddingTop ) || 0;\r\n  const paddingLeft = parseFloat( dragImageComputedStyle.paddingLeft ) || 0;\r\n  const borderTop = parseFloat( dragImageComputedStyle.borderTopWidth ) || 0;\r\n  const borderLeft = parseFloat( dragImageComputedStyle.borderLeftWidth ) || 0;\r\n\r\n  return {\r\n    x: event.offsetX + paddingLeft + borderLeft,\r\n    y: event.offsetY + paddingTop + borderTop\r\n  };\r\n}\r\n\r\nexport function setDragImage( event:DragEvent, dragImage:Element, offsetFunction:DndDragImageOffsetFunction ):void {\r\n\r\n  const offset = offsetFunction( event, dragImage ) || {x: 0, y: 0};\r\n\r\n  (event.dataTransfer as any).setDragImage( dragImage, offset.x, offset.y );\r\n}\r\n","import {\r\n  CUSTOM_MIME_TYPE,\r\n  DROP_EFFECTS,\r\n  filterEffects,\r\n  getWellKnownMimeType,\r\n  JSON_MIME_TYPE,\r\n  MSIE_MIME_TYPE\r\n} from \"./dnd-utils\";\r\nimport { DropEffect, EffectAllowed } from \"./dnd-types\";\r\n\r\nexport interface DndState {\r\n  isDragging:boolean;\r\n  dropEffect?:DropEffect;\r\n  effectAllowed?:EffectAllowed;\r\n  type?:string;\r\n}\r\n\r\nconst _dndState:DndState = {\r\n  isDragging: false,\r\n  dropEffect: \"none\",\r\n  effectAllowed: \"all\",\r\n  type: undefined\r\n};\r\n\r\nexport function startDrag( event:DragEvent, effectAllowed:EffectAllowed, type:string | undefined ) {\r\n\r\n  _dndState.isDragging = true;\r\n  _dndState.dropEffect = \"none\";\r\n  _dndState.effectAllowed = effectAllowed;\r\n  _dndState.type = type;\r\n\r\n  event.dataTransfer.effectAllowed = effectAllowed;\r\n}\r\n\r\nexport function endDrag() {\r\n\r\n  _dndState.isDragging = false;\r\n  _dndState.dropEffect = undefined;\r\n  _dndState.effectAllowed = undefined;\r\n  _dndState.type = undefined;\r\n}\r\n\r\nexport function setDropEffect( event:DragEvent, dropEffect:DropEffect ) {\r\n\r\n  if( _dndState.isDragging === true ) {\r\n\r\n    _dndState.dropEffect = dropEffect;\r\n  }\r\n\r\n  event.dataTransfer.dropEffect = dropEffect;\r\n}\r\n\r\nexport function getDropEffect( event:DragEvent, effectAllowed?:EffectAllowed | DropEffect ):DropEffect {\r\n\r\n  const dataTransferEffectAllowed:EffectAllowed = (event.dataTransfer) ? event.dataTransfer.effectAllowed as EffectAllowed : \"uninitialized\";\r\n\r\n  let effects = filterEffects( DROP_EFFECTS, dataTransferEffectAllowed );\r\n\r\n  if( _dndState.isDragging === true ) {\r\n\r\n    effects = filterEffects( effects, _dndState.effectAllowed );\r\n  }\r\n\r\n  if( effectAllowed ) {\r\n\r\n    effects = filterEffects( effects, effectAllowed );\r\n  }\r\n\r\n  // MacOS automatically filters dataTransfer.effectAllowed depending on the modifier keys,\r\n  // therefore the following modifier keys will only affect other operating systems.\r\n  if( effects.length === 0 ) {\r\n\r\n    return \"none\";\r\n  }\r\n\r\n  if( event.ctrlKey && effects.indexOf( \"copy\" ) !== -1 ) {\r\n\r\n    return \"copy\";\r\n  }\r\n\r\n  if( event.altKey && effects.indexOf( \"link\" ) !== -1 ) {\r\n\r\n    return \"link\";\r\n  }\r\n\r\n  return effects[ 0 ] as DropEffect;\r\n}\r\n\r\nexport function getDndType( event:DragEvent ):string | undefined {\r\n\r\n  if( _dndState.isDragging === true ) {\r\n\r\n    return _dndState.type;\r\n  }\r\n\r\n  const mimeType = getWellKnownMimeType( event );\r\n\r\n  if( mimeType === null ) {\r\n\r\n    return undefined;\r\n  }\r\n\r\n  if( mimeType === MSIE_MIME_TYPE\r\n    || mimeType === JSON_MIME_TYPE ) {\r\n\r\n    return undefined;\r\n  }\r\n\r\n  return mimeType.substr( CUSTOM_MIME_TYPE.length + 1 ) || undefined;\r\n}\r\n\r\nexport function isExternalDrag():boolean {\r\n\r\n  return _dndState.isDragging === false;\r\n}\r\n\r\nexport const dndState:Readonly<DndState> = _dndState as Readonly<DndState>;\r\n","import {\r\n  AfterViewInit,\r\n  Directive,\r\n  ElementRef,\r\n  EventEmitter,\r\n  HostBinding,\r\n  HostListener,\r\n  Input,\r\n  NgZone,\r\n  OnDestroy,\r\n  Output,\r\n  Renderer2\r\n} from \"@angular/core\";\r\nimport { calculateDragImageOffset, DndDragImageOffsetFunction, DndEvent, setDragData, setDragImage } from \"./dnd-utils\";\r\nimport { DndHandleDirective } from \"./dnd-handle.directive\";\r\nimport { dndState, endDrag, startDrag } from \"./dnd-state\";\r\nimport { EffectAllowed } from \"./dnd-types\";\r\n\r\n@Directive( {\r\n  selector: \"[dndDragImageRef]\"\r\n} )\r\nexport class DndDragImageRefDirective {\r\n\r\n  constructor( parent:DndDraggableDirective,\r\n               elementRef:ElementRef ) {\r\n\r\n    parent.registerDragImage( elementRef );\r\n  }\r\n}\r\n\r\n@Directive( {\r\n  selector: \"[dndDraggable]\",\r\n  exportAs: \"ngxDraggable\"\r\n} )\r\nexport class DndDraggableDirective implements AfterViewInit, OnDestroy {\r\n\r\n  @Input()\r\n  dndDraggable:any;\r\n\r\n  @Input()\r\n  dndEffectAllowed:EffectAllowed = \"copy\";\r\n\r\n  @Input()\r\n  dndType?:string;\r\n\r\n  @Input()\r\n  dndDraggingClass = \"dndDragging\";\r\n\r\n  @Input()\r\n  dndDraggingSourceClass = \"dndDraggingSource\";\r\n\r\n  @Input()\r\n  dndDraggableDisabledClass = \"dndDraggableDisabled\";\r\n\r\n  @Input()\r\n  dndDragImageOffsetFunction:DndDragImageOffsetFunction = calculateDragImageOffset;\r\n\r\n  @Output()\r\n  readonly dndStart:EventEmitter<DragEvent> = new EventEmitter<DragEvent>();\r\n\r\n  @Output()\r\n  readonly dndDrag:EventEmitter<DragEvent> = new EventEmitter<DragEvent>();\r\n\r\n  @Output()\r\n  readonly dndEnd:EventEmitter<DragEvent> = new EventEmitter<DragEvent>();\r\n\r\n  @Output()\r\n  readonly dndMoved:EventEmitter<DragEvent> = new EventEmitter<DragEvent>();\r\n\r\n  @Output()\r\n  readonly dndCopied:EventEmitter<DragEvent> = new EventEmitter<DragEvent>();\r\n\r\n  @Output()\r\n  readonly dndLinked:EventEmitter<DragEvent> = new EventEmitter<DragEvent>();\r\n\r\n  @Output()\r\n  readonly dndCanceled:EventEmitter<DragEvent> = new EventEmitter<DragEvent>();\r\n\r\n  @HostBinding( \"attr.draggable\" )\r\n  draggable = true;\r\n\r\n  private dndHandle?:DndHandleDirective;\r\n\r\n  private dndDragImageElementRef?:ElementRef;\r\n\r\n  private dragImage:Element;\r\n\r\n  private isDragStarted:boolean = false;\r\n\r\n  private readonly dragEventHandler:( event:DragEvent ) => void = ( event:DragEvent ) => this.onDrag( event );\r\n\r\n  private dragStartListener;\r\n  private dragEndListener;\r\n\r\n  private componentThatLocked: any;\r\n\r\n  @Input()\r\n  set dndDisableIf( value:boolean ) {\r\n\r\n    this.draggable = !value;\r\n\r\n    if( this.draggable ) {\r\n\r\n      this.renderer.removeClass( this.elementRef.nativeElement, this.dndDraggableDisabledClass );\r\n    }\r\n    else {\r\n\r\n      this.renderer.addClass( this.elementRef.nativeElement, this.dndDraggableDisabledClass );\r\n    }\r\n  }\r\n\r\n  @Input()\r\n  set dndDisableDragIf( value:boolean ) {\r\n    this.dndDisableIf = value;\r\n  }\r\n\r\n  constructor( private elementRef:ElementRef,\r\n               private renderer:Renderer2,\r\n               private ngZone:NgZone ) {\r\n  }\r\n\r\n  ngAfterViewInit():void {\r\n    this.addHostListeners();\r\n    this.ngZone.runOutsideAngular( () => {\r\n      this.elementRef.nativeElement.addEventListener( \"drag\", this.dragEventHandler );\r\n    } );\r\n  }\r\n\r\n  ngOnDestroy():void {\r\n    this.elementRef.nativeElement.removeEventListener( \"drag\", this.dragEventHandler );\r\n    if(this.isDragStarted === true) {\r\n      endDrag()\r\n    }\r\n  }\r\n\r\n  \r\n  toggleDragLock(value: boolean, component: any, force: boolean = false):void {\r\n    if (value) {\r\n      this.componentThatLocked = component;\r\n      this.removeHostListeners();\r\n    } else if(component === this.componentThatLocked) {\r\n      this.componentThatLocked = null;\r\n      this.addHostListeners();\r\n    }\r\n  }\r\n\r\n  //@HostListener( \"dragstart\", [ \"$event\" ] )\r\n  onDragStart( event:DndEvent ) {\r\n\r\n    if( this.draggable === false ) {\r\n\r\n      return false;\r\n    }\r\n\r\n    // check if there is dnd handle and if the dnd handle was used to start the drag\r\n    if( typeof this.dndHandle !== \"undefined\"\r\n      && typeof event._dndUsingHandle === \"undefined\" ) {\r\n\r\n      return false;\r\n    }\r\n\r\n    // initialize global state\r\n    startDrag( event, this.dndEffectAllowed, this.dndType );\r\n\r\n    this.isDragStarted = true;\r\n\r\n    setDragData( event, {data: this.dndDraggable, type: this.dndType}, dndState.effectAllowed );\r\n\r\n    this.dragImage = this.determineDragImage();\r\n\r\n    // set dragging css class prior to setDragImage so styles are applied before\r\n    // TODO breaking change: add class to elementRef rather than drag image which could be another element\r\n    this.renderer.addClass( this.dragImage, this.dndDraggingClass );\r\n\r\n    // set custom dragimage if present\r\n    // set dragimage if drag is started from dndHandle\r\n    if( typeof this.dndDragImageElementRef !== \"undefined\"\r\n      || typeof event._dndUsingHandle !== \"undefined\" ) {\r\n\r\n      setDragImage( event, this.dragImage, this.dndDragImageOffsetFunction );\r\n    }\r\n\r\n    // add dragging source css class on first drag event\r\n    const unregister = this.renderer.listen( this.elementRef.nativeElement, \"drag\", () => {\r\n\r\n      this.renderer.addClass( this.elementRef.nativeElement, this.dndDraggingSourceClass );\r\n      unregister();\r\n    } );\r\n\r\n    this.dndStart.emit( event );\r\n\r\n    // event.stopPropagation();\r\n  }\r\n\r\n  onDrag( event:DragEvent ) {\r\n\r\n    this.dndDrag.emit( event );\r\n  }\r\n\r\n  //@HostListener( \"dragend\", [ \"$event\" ] )\r\n  onDragEnd( event:DragEvent ) {\r\n\r\n    // get drop effect from custom stored state as its not reliable across browsers\r\n    const dropEffect = dndState.dropEffect;\r\n\r\n    let dropEffectEmitter:EventEmitter<DragEvent>;\r\n\r\n    switch( dropEffect ) {\r\n\r\n      case \"copy\":\r\n        dropEffectEmitter = this.dndCopied;\r\n        break;\r\n\r\n      case \"link\":\r\n        dropEffectEmitter = this.dndLinked;\r\n        break;\r\n\r\n      case \"move\":\r\n        dropEffectEmitter = this.dndMoved;\r\n        break;\r\n\r\n      default:\r\n        dropEffectEmitter = this.dndCanceled;\r\n        break;\r\n    }\r\n\r\n    dropEffectEmitter.emit( event );\r\n    this.dndEnd.emit( event );\r\n\r\n    // reset global state\r\n    endDrag();\r\n\r\n    this.isDragStarted = false;\r\n\r\n    this.renderer.removeClass( this.dragImage, this.dndDraggingClass );\r\n\r\n    // IE9 special hammering\r\n    window.setTimeout( () => {\r\n      this.renderer.removeClass( this.elementRef.nativeElement, this.dndDraggingSourceClass );\r\n    }, 0 );\r\n\r\n    event.stopPropagation();\r\n  }\r\n\r\n  registerDragHandle( handle:DndHandleDirective | undefined ) {\r\n\r\n    this.dndHandle = handle;\r\n  }\r\n\r\n  registerDragImage( elementRef:ElementRef | undefined ) {\r\n\r\n    this.dndDragImageElementRef = elementRef;\r\n  }\r\n\r\n  private determineDragImage():Element {\r\n\r\n    // evaluate custom drag image existence\r\n    if( typeof this.dndDragImageElementRef !== \"undefined\" ) {\r\n\r\n      return this.dndDragImageElementRef.nativeElement as Element;\r\n    }\r\n    else {\r\n\r\n      return this.elementRef.nativeElement;\r\n    }\r\n  }\r\n\r\n  private addHostListeners():void {\r\n    this.draggable = true;\r\n    if (!this.dragStartListener) {\r\n      this.dragStartListener = this.renderer.listen(this.elementRef.nativeElement, 'dragstart', this.onDragStart.bind(this));\r\n    }\r\n    if (!this.dragEndListener) {\r\n      this.dragEndListener = this.renderer.listen(this.elementRef.nativeElement, 'dragend', this.onDragEnd.bind(this));\r\n    }\r\n  }\r\n\r\n\r\n  private removeHostListeners():void {\r\n    this.draggable = false;\r\n    if(this.dragStartListener) {\r\n      this.dragStartListener();\r\n    }\r\n    if(this.dragEndListener){\r\n      this.dragEndListener();\r\n    }\r\n  }\r\n}\r\n","import {\r\n  AfterViewInit,\r\n  ContentChild,\r\n  Directive,\r\n  ElementRef,\r\n  EventEmitter,\r\n  HostListener,\r\n  Input,\r\n  NgZone,\r\n  OnDestroy,\r\n  Output,\r\n  Renderer2\r\n} from \"@angular/core\";\r\nimport {\r\n  DndEvent,\r\n  DragDropData,\r\n  getDirectChildElement,\r\n  getDropData,\r\n  shouldPositionPlaceholderBeforeElement\r\n} from \"./dnd-utils\";\r\nimport { getDndType, getDropEffect, isExternalDrag, setDropEffect } from \"./dnd-state\";\r\nimport { DropEffect, EffectAllowed } from \"./dnd-types\";\r\n\r\nexport interface DndDropEvent {\r\n  event:DragEvent;\r\n  dropEffect:DropEffect;\r\n  isExternal:boolean;\r\n  data?:any;\r\n  index?:number;\r\n  type?:any;\r\n}\r\n\r\n@Directive( {\r\n  selector: \"[dndPlaceholderRef]\"\r\n} )\r\nexport class DndPlaceholderRefDirective {\r\n\r\n  constructor( public readonly elementRef:ElementRef ) {\r\n  }\r\n}\r\n\r\n@Directive( {\r\n  selector: \"[dndDropzone]\"\r\n} )\r\nexport class DndDropzoneDirective implements AfterViewInit, OnDestroy {\r\n\r\n  @Input()\r\n  dndDropzone?:string[];\r\n\r\n  @Input()\r\n  dndEffectAllowed:EffectAllowed;\r\n\r\n  @Input()\r\n  dndAllowExternal:boolean = false;\r\n\r\n  @Input()\r\n  dndHorizontal:boolean = false;\r\n\r\n  @Input()\r\n  dndDragoverClass:string = \"dndDragover\";\r\n\r\n  @Input()\r\n  dndDropzoneDisabledClass = \"dndDropzoneDisabled\";\r\n\r\n  @Output()\r\n  readonly dndDragover:EventEmitter<DragEvent> = new EventEmitter<DragEvent>();\r\n\r\n  @Output()\r\n  readonly dndDrop:EventEmitter<DndDropEvent> = new EventEmitter<DndDropEvent>();\r\n\r\n  @ContentChild( DndPlaceholderRefDirective )\r\n  private readonly dndPlaceholderRef?:DndPlaceholderRefDirective;\r\n\r\n  private placeholder:Element | null = null;\r\n\r\n  private disabled:boolean = false;\r\n\r\n  private readonly dragEnterEventHandler:( event:DragEvent ) => void = ( event:DragEvent ) => this.onDragEnter( event );\r\n  private readonly dragOverEventHandler:( event:DragEvent ) => void = ( event:DragEvent ) => this.onDragOver( event );\r\n  private readonly dragLeaveEventHandler:( event:DragEvent ) => void = ( event:DragEvent ) => this.onDragLeave( event );\r\n\r\n  @Input()\r\n  set dndDisableIf( value:boolean ) {\r\n\r\n    this.disabled = !!value;\r\n\r\n    if( this.disabled ) {\r\n\r\n      this.renderer.addClass( this.elementRef.nativeElement, this.dndDropzoneDisabledClass );\r\n    }\r\n    else {\r\n\r\n      this.renderer.removeClass( this.elementRef.nativeElement, this.dndDropzoneDisabledClass );\r\n    }\r\n  }\r\n\r\n  @Input()\r\n  set dndDisableDropIf( value:boolean ) {\r\n    this.dndDisableIf = value;\r\n  }\r\n\r\n  constructor( private ngZone:NgZone,\r\n               private elementRef:ElementRef,\r\n               private renderer:Renderer2 ) {\r\n  }\r\n\r\n  ngAfterViewInit():void {\r\n\r\n    this.placeholder = this.tryGetPlaceholder();\r\n\r\n    this.removePlaceholderFromDOM();\r\n\r\n    this.ngZone.runOutsideAngular( () => {\r\n      this.elementRef.nativeElement.addEventListener( \"dragenter\", this.dragEnterEventHandler );\r\n      this.elementRef.nativeElement.addEventListener( \"dragover\", this.dragOverEventHandler );\r\n      this.elementRef.nativeElement.addEventListener( \"dragleave\", this.dragLeaveEventHandler );\r\n    } );\r\n  }\r\n\r\n  ngOnDestroy():void {\r\n    this.elementRef.nativeElement.removeEventListener( \"dragenter\", this.dragEnterEventHandler );\r\n    this.elementRef.nativeElement.removeEventListener( \"dragover\", this.dragOverEventHandler );\r\n    this.elementRef.nativeElement.removeEventListener( \"dragleave\", this.dragLeaveEventHandler );\r\n  }\r\n\r\n  onDragEnter( event:DndEvent ) {\r\n\r\n    // check if another dropzone is activated\r\n    if( event._dndDropzoneActive === true ) {\r\n\r\n      this.cleanupDragoverState();\r\n      return;\r\n    }\r\n\r\n    // set as active if the target element is inside this dropzone\r\n    if( typeof event._dndDropzoneActive === \"undefined\" ) {\r\n\r\n      const newTarget = document.elementFromPoint( event.clientX, event.clientY );\r\n\r\n      if( this.elementRef.nativeElement.contains( newTarget ) ) {\r\n\r\n        event._dndDropzoneActive = true;\r\n      }\r\n    }\r\n\r\n    // check if this drag event is allowed to drop on this dropzone\r\n    const type = getDndType( event );\r\n    if( this.isDropAllowed( type ) === false ) {\r\n\r\n      return;\r\n    }\r\n\r\n    // allow the dragenter\r\n    event.preventDefault();\r\n  }\r\n\r\n  onDragOver( event:DragEvent ) {\r\n    // With nested dropzones, we want to ignore this event if a child dropzone\r\n    // has already handled a dragover.  Historically, event.stopPropagation() was\r\n    // used to prevent this bubbling, but that prevents any dragovers outside the\r\n    // ngx-drag-drop component, and stops other use cases such as scrolling on drag.\r\n    // Instead, we can check if the event was already prevented by a child and bail early.\r\n    if( event.defaultPrevented ) {\r\n\r\n      return;\r\n    }\r\n\r\n    // check if this drag event is allowed to drop on this dropzone\r\n    const type = getDndType( event );\r\n    if( this.isDropAllowed( type ) === false ) {\r\n\r\n      return;\r\n    }\r\n\r\n    this.checkAndUpdatePlaceholderPosition( event );\r\n\r\n    const dropEffect = getDropEffect( event, this.dndEffectAllowed );\r\n\r\n    if( dropEffect === \"none\" ) {\r\n\r\n      this.cleanupDragoverState();\r\n      return;\r\n    }\r\n\r\n    // allow the dragover\r\n    event.preventDefault();\r\n\r\n    // set the drop effect\r\n    setDropEffect( event, dropEffect );\r\n\r\n    this.dndDragover.emit( event );\r\n\r\n    this.renderer.addClass( this.elementRef.nativeElement, this.dndDragoverClass );\r\n  }\r\n\r\n  @HostListener( \"drop\", [ \"$event\" ] )\r\n  onDrop( event:DragEvent ) {\r\n\r\n    try {\r\n\r\n      // check if this drag event is allowed to drop on this dropzone\r\n      const type = getDndType( event );\r\n      if( this.isDropAllowed( type ) === false ) {\r\n\r\n        return;\r\n      }\r\n\r\n      const data:DragDropData = getDropData( event, isExternalDrag() );\r\n\r\n      if( this.isDropAllowed( data.type ) === false ) {\r\n\r\n        return;\r\n      }\r\n\r\n      // signal custom drop handling\r\n      event.preventDefault();\r\n\r\n      const dropEffect = getDropEffect( event );\r\n\r\n      setDropEffect( event, dropEffect );\r\n\r\n      if( dropEffect === \"none\" ) {\r\n\r\n        return;\r\n      }\r\n\r\n      const dropIndex = this.getPlaceholderIndex();\r\n\r\n      // if for whatever reason the placeholder is not present in the DOM but it should be there\r\n      // we don't allow/emit the drop event since it breaks the contract\r\n      // seems to only happen if drag and drop is executed faster than the DOM updates\r\n      if( dropIndex === -1 ) {\r\n\r\n        return;\r\n      }\r\n\r\n      this.dndDrop.emit( {\r\n        event: event,\r\n        dropEffect: dropEffect,\r\n        isExternal: isExternalDrag(),\r\n        data: data.data,\r\n        index: dropIndex,\r\n        type: type,\r\n      } );\r\n\r\n      event.stopPropagation();\r\n\r\n    }\r\n    finally {\r\n\r\n      this.cleanupDragoverState();\r\n    }\r\n  }\r\n\r\n  onDragLeave( event:DndEvent ) {\r\n\r\n    // check if still inside this dropzone and not yet handled by another dropzone\r\n    if( typeof event._dndDropzoneActive === \"undefined\" ) {\r\n\r\n      const newTarget = document.elementFromPoint( event.clientX, event.clientY );\r\n\r\n      if( this.elementRef.nativeElement.contains( newTarget ) ) {\r\n\r\n        event._dndDropzoneActive = true;\r\n        return;\r\n      }\r\n    }\r\n\r\n    this.cleanupDragoverState();\r\n\r\n    // cleanup drop effect when leaving dropzone\r\n    setDropEffect( event, \"none\" );\r\n  }\r\n\r\n  private isDropAllowed( type?:string ):boolean {\r\n\r\n    // dropzone is disabled -> deny it\r\n    if( this.disabled === true ) {\r\n\r\n      return false;\r\n    }\r\n\r\n    // if drag did not start from our directive\r\n    // and external drag sources are not allowed -> deny it\r\n    if( isExternalDrag() === true\r\n      && this.dndAllowExternal === false ) {\r\n\r\n      return false;\r\n    }\r\n\r\n    // no filtering by types -> allow it\r\n    if( !this.dndDropzone ) {\r\n\r\n      return true;\r\n    }\r\n\r\n    // no type set -> allow it\r\n    if( !type ) {\r\n\r\n      return true;\r\n    }\r\n\r\n    if( Array.isArray( this.dndDropzone ) === false ) {\r\n\r\n      throw new Error( \"dndDropzone: bound value to [dndDropzone] must be an array!\" );\r\n    }\r\n\r\n    // if dropzone contains type -> allow it\r\n    return this.dndDropzone.indexOf( type ) !== -1;\r\n  }\r\n\r\n  private tryGetPlaceholder():Element | null {\r\n\r\n    if( typeof this.dndPlaceholderRef !== \"undefined\" ) {\r\n\r\n      return this.dndPlaceholderRef.elementRef.nativeElement as Element;\r\n    }\r\n\r\n    // TODO nasty workaround needed because if ng-container / template is used @ContentChild() or DI will fail because\r\n    // of wrong context see angular bug https://github.com/angular/angular/issues/13517\r\n    return this.elementRef.nativeElement.querySelector( \"[dndPlaceholderRef]\" );\r\n  }\r\n\r\n  private removePlaceholderFromDOM() {\r\n\r\n    if( this.placeholder !== null\r\n      && this.placeholder.parentNode !== null ) {\r\n      this.placeholder.parentNode.removeChild( this.placeholder );\r\n    }\r\n  }\r\n\r\n  private checkAndUpdatePlaceholderPosition( event:DragEvent ):void {\r\n\r\n    if( this.placeholder === null ) {\r\n\r\n      return;\r\n    }\r\n\r\n    // make sure the placeholder is in the DOM\r\n    if( this.placeholder.parentNode !== this.elementRef.nativeElement ) {\r\n\r\n      this.renderer.appendChild( this.elementRef.nativeElement, this.placeholder );\r\n    }\r\n\r\n    // update the position if the event originates from a child element of the dropzone\r\n    const directChild = getDirectChildElement( this.elementRef.nativeElement, event.target as Element );\r\n\r\n    // early exit if no direct child or direct child is placeholder\r\n    if( directChild === null\r\n      || directChild === this.placeholder ) {\r\n\r\n      return;\r\n    }\r\n\r\n    const positionPlaceholderBeforeDirectChild = shouldPositionPlaceholderBeforeElement( event, directChild, this.dndHorizontal );\r\n\r\n    if( positionPlaceholderBeforeDirectChild ) {\r\n\r\n      // do insert before only if necessary\r\n      if( directChild.previousSibling !== this.placeholder ) {\r\n\r\n        this.renderer.insertBefore( this.elementRef.nativeElement, this.placeholder, directChild );\r\n      }\r\n    }\r\n    else {\r\n\r\n      // do insert after only if necessary\r\n      if( directChild.nextSibling !== this.placeholder ) {\r\n\r\n        this.renderer.insertBefore( this.elementRef.nativeElement, this.placeholder, directChild.nextSibling );\r\n      }\r\n    }\r\n  }\r\n\r\n  private getPlaceholderIndex():number | undefined {\r\n\r\n    if( this.placeholder === null ) {\r\n\r\n      return undefined;\r\n    }\r\n\r\n    const element = this.elementRef.nativeElement as HTMLElement;\r\n\r\n    return Array.prototype.indexOf.call( element.children, this.placeholder );\r\n  }\r\n\r\n  private cleanupDragoverState() {\r\n\r\n    this.renderer.removeClass( this.elementRef.nativeElement, this.dndDragoverClass );\r\n\r\n    this.removePlaceholderFromDOM();\r\n  }\r\n}\r\n","import { Directive, HostBinding, HostListener } from \"@angular/core\";\r\nimport { DndEvent } from \"./dnd-utils\";\r\nimport { DndDraggableDirective } from \"./dnd-draggable.directive\";\r\n\r\n@Directive( {\r\n  selector: \"[dndHandle]\"\r\n} )\r\nexport class DndHandleDirective {\r\n\r\n  @HostBinding( \"attr.draggable\" )\r\n  draggable = true;\r\n\r\n  constructor(private parent:DndDraggableDirective ) {\r\n\r\n    parent.registerDragHandle( this );\r\n  }\r\n\r\n  @HostListener( \"dragstart\", [ \"$event\" ] )\r\n  @HostListener( \"dragend\", [ \"$event\" ] )\r\n  onDragEvent( event:DndEvent ) {\r\n    this.parent.toggleDragLock(false, null, true);\r\n    event._dndUsingHandle = true;\r\n  }\r\n}\r\n","import { NgModule } from \"@angular/core\";\r\nimport { CommonModule } from \"@angular/common\";\r\nimport { DndDraggableDirective, DndDragImageRefDirective } from \"./dnd-draggable.directive\";\r\nimport { DndDropzoneDirective, DndPlaceholderRefDirective } from \"./dnd-dropzone.directive\";\r\nimport { DndHandleDirective } from \"./dnd-handle.directive\";\r\n\r\n@NgModule( {\r\n  imports: [\r\n    CommonModule\r\n  ],\r\n  declarations: [\r\n    DndDraggableDirective,\r\n    DndDropzoneDirective,\r\n    DndHandleDirective,\r\n    DndPlaceholderRefDirective,\r\n    DndDragImageRefDirective\r\n  ],\r\n  exports: [\r\n    DndDraggableDirective,\r\n    DndDropzoneDirective,\r\n    DndHandleDirective,\r\n    DndPlaceholderRefDirective,\r\n    DndDragImageRefDirective\r\n  ]\r\n} )\r\nexport class DndModule {\r\n}\r\n"]}