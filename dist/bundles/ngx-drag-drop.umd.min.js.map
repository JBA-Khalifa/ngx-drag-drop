{"version":3,"sources":["ng://ngx-drag-drop/dnd-utils.ts","ng://ngx-drag-drop/dnd-state.ts","ng://ngx-drag-drop/dnd-draggable.directive.ts","ng://ngx-drag-drop/dnd-dropzone.directive.ts","ng://ngx-drag-drop/dnd-handle.directive.ts","ng://ngx-drag-drop/dnd.module.ts"],"names":["DROP_EFFECTS","CUSTOM_MIME_TYPE","JSON_MIME_TYPE","MSIE_MIME_TYPE","mimeTypeIsCustom","mimeType","substr","length","getWellKnownMimeType","event","dataTransfer","types","i","filterEffects","effects","allowed","filter","effect","toLowerCase","indexOf","calculateDragImageOffset","dragImage","dragImageComputedStyle","window","getComputedStyle","paddingTop","parseFloat","paddingLeft","borderTop","borderTopWidth","borderLeft","borderLeftWidth","x","offsetX","y","offsetY","_dndState","isDragging","dropEffect","effectAllowed","type","undefined","endDrag","setDropEffect","getDropEffect","dataTransferEffectAllowed","ctrlKey","altKey","getDndType","isExternalDrag","dndState","DndDragImageRefDirective","parent","elementRef","registerDragImage","Directive","args","selector","DndDraggableDirective","ElementRef","renderer","ngZone","_this","this","dndEffectAllowed","dndDraggingClass","dndDraggingSourceClass","dndDraggableDisabledClass","dndDragImageOffsetFunction","dndStart","EventEmitter","dndDrag","dndEnd","dndMoved","dndCopied","dndLinked","dndCanceled","draggable","isDragStarted","dragEventHandler","onDrag","Object","defineProperty","prototype","value","removeClass","nativeElement","addClass","dndDisableIf","ngAfterViewInit","runOutsideAngular","addEventListener","ngOnDestroy","removeEventListener","onDragStart","dndHandle","_dndUsingHandle","startDrag","dndType","setDragData","data","dataString","JSON","stringify","setData","e","effectsAllowed","dndDraggable","determineDragImage","dndDragImageElementRef","setDragImage","offsetFunction","offset","unregister","listen","emit","onDragEnd","dropEffectEmitter","setTimeout","stopPropagation","registerDragHandle","handle","Renderer2","NgZone","Input","Output","HostBinding","HostListener","DndPlaceholderRefDirective","DndDropzoneDirective","dndAllowExternal","dndHorizontal","dndDragoverClass","dndDropzoneDisabledClass","dndDragover","dndDrop","placeholder","disabled","dragEnterEventHandler","onDragEnter","dragOverEventHandler","onDragOver","dragLeaveEventHandler","onDragLeave","tryGetPlaceholder","removePlaceholderFromDOM","_dndDropzoneActive","newTarget","document","elementFromPoint","clientX","clientY","contains","isDropAllowed","preventDefault","cleanupDragoverState","defaultPrevented","checkAndUpdatePlaceholderPosition","onDrop","getDropData","dragIsExternal","parse","getData","dropIndex","getPlaceholderIndex","isExternal","index","dndDropzone","Array","isArray","Error","dndPlaceholderRef","querySelector","parentNode","removeChild","appendChild","directChild","getDirectChildElement","parentElement","childElement","shouldPositionPlaceholderBeforeElement","element","horizontal","bounds","getBoundingClientRect","left","width","top","height","previousSibling","insertBefore","nextSibling","call","children","ContentChild","DndHandleDirective","onDragEvent","DndModule","NgModule","imports","CommonModule","declarations","exports"],"mappings":"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","sourcesContent":["import { DropEffect, EffectAllowed } from \"./dnd-types\";\r\n\r\nexport interface DragDropData {\r\n  data?:any;\r\n  type?:string;\r\n}\r\n\r\nexport interface DndEvent extends DragEvent {\r\n  _dndUsingHandle?:boolean;\r\n  _dndDropzoneActive?:true;\r\n}\r\n\r\nexport type DndDragImageOffsetFunction = ( event:DragEvent, dragImage:Element ) => { x:number, y:number };\r\n\r\nexport const DROP_EFFECTS = [ \"move\", \"copy\", \"link\" ] as DropEffect[];\r\n\r\nexport const CUSTOM_MIME_TYPE = \"application/x-dnd\";\r\nexport const JSON_MIME_TYPE = \"application/json\";\r\nexport const MSIE_MIME_TYPE = \"Text\";\r\n\r\nfunction mimeTypeIsCustom( mimeType:string ) {\r\n\r\n  return mimeType.substr( 0, CUSTOM_MIME_TYPE.length ) === CUSTOM_MIME_TYPE;\r\n}\r\n\r\nexport function getWellKnownMimeType( event:DragEvent ):string | null {\r\n\r\n  if( event.dataTransfer ) {\r\n\r\n    const types = event.dataTransfer.types;\r\n\r\n    // IE 9 workaround.\r\n    if( !types ) {\r\n\r\n      return MSIE_MIME_TYPE;\r\n    }\r\n\r\n    for( let i = 0; i < types.length; i++ ) {\r\n\r\n      if( types[ i ] === MSIE_MIME_TYPE\r\n        || types[ i ] === JSON_MIME_TYPE\r\n        || mimeTypeIsCustom( types[ i ] ) ) {\r\n\r\n        return types[ i ];\r\n      }\r\n    }\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nexport function setDragData( event:DragEvent, data:DragDropData, effectAllowed:EffectAllowed ):void {\r\n\r\n  // Internet Explorer and Microsoft Edge don't support custom mime types, see design doc:\r\n  // https://github.com/marceljuenemann/angular-drag-and-drop-lists/wiki/Data-Transfer-Design\r\n  const mimeType = CUSTOM_MIME_TYPE + (data.type ? (\"-\" + data.type) : \"\");\r\n\r\n  const dataString = JSON.stringify( data );\r\n\r\n  try {\r\n\r\n    event.dataTransfer.setData( mimeType, dataString );\r\n\r\n  }\r\n  catch( e ) {\r\n\r\n    //   Setting a custom MIME type did not work, we are probably in IE or Edge.\r\n    try {\r\n\r\n      event.dataTransfer.setData( JSON_MIME_TYPE, dataString );\r\n\r\n    }\r\n    catch( e ) {\r\n\r\n      //   We are in Internet Explorer and can only use the Text MIME type. Also note that IE\r\n      //   does not allow changing the cursor in the dragover event, therefore we have to choose\r\n      //   the one we want to display now by setting effectAllowed.\r\n      const effectsAllowed = filterEffects( DROP_EFFECTS, effectAllowed );\r\n      event.dataTransfer.effectAllowed = effectsAllowed[ 0 ];\r\n\r\n      event.dataTransfer.setData( MSIE_MIME_TYPE, dataString );\r\n    }\r\n  }\r\n}\r\n\r\nexport function getDropData( event:DragEvent, dragIsExternal:boolean ):DragDropData {\r\n\r\n  // check if the mime type is well known\r\n  const mimeType = getWellKnownMimeType( event );\r\n\r\n  // drag did not originate from [dndDraggable]\r\n  if( dragIsExternal === true ) {\r\n\r\n    if( mimeType !== null\r\n      && mimeTypeIsCustom( mimeType ) ) {\r\n\r\n      // the type of content is well known and safe to handle\r\n      return JSON.parse( event.dataTransfer.getData( mimeType ) );\r\n    }\r\n\r\n    // the contained data is unknown, let user handle it\r\n    return {};\r\n  }\r\n\r\n  // the type of content is well known and safe to handle\r\n  return JSON.parse( event.dataTransfer.getData( mimeType ) );\r\n}\r\n\r\nexport function filterEffects( effects:DropEffect[], allowed:EffectAllowed | DropEffect ):DropEffect[] {\r\n\r\n  if( allowed === \"all\"\r\n    || allowed === \"uninitialized\" ) {\r\n\r\n    return effects;\r\n  }\r\n\r\n  return effects.filter( function( effect ) {\r\n\r\n    return allowed.toLowerCase().indexOf( effect ) !== -1;\r\n  } );\r\n}\r\n\r\nexport function getDirectChildElement( parentElement:Element, childElement:Element ):Element | null {\r\n\r\n  let directChild:Node = childElement;\r\n\r\n  while( directChild.parentNode !== parentElement ) {\r\n\r\n    // reached root node without finding given parent\r\n    if( !directChild.parentNode ) {\r\n\r\n      return null;\r\n    }\r\n\r\n    directChild = directChild.parentNode;\r\n  }\r\n\r\n  return directChild as Element;\r\n}\r\n\r\nexport function shouldPositionPlaceholderBeforeElement( event:DragEvent, element:Element, horizontal:boolean ) {\r\n\r\n  const bounds = element.getBoundingClientRect();\r\n\r\n  // If the pointer is in the upper half of the list item element,\r\n  // we position the placeholder before the list item, otherwise after it.\r\n  if( horizontal ) {\r\n\r\n    return (event.clientX < bounds.left + bounds.width / 2);\r\n  }\r\n\r\n  return (event.clientY < bounds.top + bounds.height / 2);\r\n}\r\n\r\nexport function calculateDragImageOffset( event:DragEvent, dragImage:Element ):{ x:number, y:number } {\r\n\r\n  const dragImageComputedStyle = window.getComputedStyle( dragImage );\r\n  const paddingTop = parseFloat( dragImageComputedStyle.paddingTop ) || 0;\r\n  const paddingLeft = parseFloat( dragImageComputedStyle.paddingLeft ) || 0;\r\n  const borderTop = parseFloat( dragImageComputedStyle.borderTopWidth ) || 0;\r\n  const borderLeft = parseFloat( dragImageComputedStyle.borderLeftWidth ) || 0;\r\n\r\n  return {\r\n    x: event.offsetX + paddingLeft + borderLeft,\r\n    y: event.offsetY + paddingTop + borderTop\r\n  };\r\n}\r\n\r\nexport function setDragImage( event:DragEvent, dragImage:Element, offsetFunction:DndDragImageOffsetFunction ):void {\r\n\r\n  const offset = offsetFunction( event, dragImage ) || {x: 0, y: 0};\r\n\r\n  (event.dataTransfer as any).setDragImage( dragImage, offset.x, offset.y );\r\n}\r\n","import {\r\n  CUSTOM_MIME_TYPE,\r\n  DROP_EFFECTS,\r\n  filterEffects,\r\n  getWellKnownMimeType,\r\n  JSON_MIME_TYPE,\r\n  MSIE_MIME_TYPE\r\n} from \"./dnd-utils\";\r\nimport { DropEffect, EffectAllowed } from \"./dnd-types\";\r\n\r\nexport interface DndState {\r\n  isDragging:boolean;\r\n  dropEffect?:DropEffect;\r\n  effectAllowed?:EffectAllowed;\r\n  type?:string;\r\n}\r\n\r\nconst _dndState:DndState = {\r\n  isDragging: false,\r\n  dropEffect: \"none\",\r\n  effectAllowed: \"all\",\r\n  type: undefined\r\n};\r\n\r\nexport function startDrag( event:DragEvent, effectAllowed:EffectAllowed, type:string | undefined ) {\r\n\r\n  _dndState.isDragging = true;\r\n  _dndState.dropEffect = \"none\";\r\n  _dndState.effectAllowed = effectAllowed;\r\n  _dndState.type = type;\r\n\r\n  event.dataTransfer.effectAllowed = effectAllowed;\r\n}\r\n\r\nexport function endDrag() {\r\n\r\n  _dndState.isDragging = false;\r\n  _dndState.dropEffect = undefined;\r\n  _dndState.effectAllowed = undefined;\r\n  _dndState.type = undefined;\r\n}\r\n\r\nexport function setDropEffect( event:DragEvent, dropEffect:DropEffect ) {\r\n\r\n  if( _dndState.isDragging === true ) {\r\n\r\n    _dndState.dropEffect = dropEffect;\r\n  }\r\n\r\n  event.dataTransfer.dropEffect = dropEffect;\r\n}\r\n\r\nexport function getDropEffect( event:DragEvent, effectAllowed?:EffectAllowed | DropEffect ):DropEffect {\r\n\r\n  const dataTransferEffectAllowed:EffectAllowed = (event.dataTransfer) ? event.dataTransfer.effectAllowed as EffectAllowed : \"uninitialized\";\r\n\r\n  let effects = filterEffects( DROP_EFFECTS, dataTransferEffectAllowed );\r\n\r\n  if( _dndState.isDragging === true ) {\r\n\r\n    effects = filterEffects( effects, _dndState.effectAllowed );\r\n  }\r\n\r\n  if( effectAllowed ) {\r\n\r\n    effects = filterEffects( effects, effectAllowed );\r\n  }\r\n\r\n  // MacOS automatically filters dataTransfer.effectAllowed depending on the modifier keys,\r\n  // therefore the following modifier keys will only affect other operating systems.\r\n  if( effects.length === 0 ) {\r\n\r\n    return \"none\";\r\n  }\r\n\r\n  if( event.ctrlKey && effects.indexOf( \"copy\" ) !== -1 ) {\r\n\r\n    return \"copy\";\r\n  }\r\n\r\n  if( event.altKey && effects.indexOf( \"link\" ) !== -1 ) {\r\n\r\n    return \"link\";\r\n  }\r\n\r\n  return effects[ 0 ] as DropEffect;\r\n}\r\n\r\nexport function getDndType( event:DragEvent ):string | undefined {\r\n\r\n  if( _dndState.isDragging === true ) {\r\n\r\n    return _dndState.type;\r\n  }\r\n\r\n  const mimeType = getWellKnownMimeType( event );\r\n\r\n  if( mimeType === null ) {\r\n\r\n    return undefined;\r\n  }\r\n\r\n  if( mimeType === MSIE_MIME_TYPE\r\n    || mimeType === JSON_MIME_TYPE ) {\r\n\r\n    return undefined;\r\n  }\r\n\r\n  return mimeType.substr( CUSTOM_MIME_TYPE.length + 1 ) || undefined;\r\n}\r\n\r\nexport function isExternalDrag():boolean {\r\n\r\n  return _dndState.isDragging === false;\r\n}\r\n\r\nexport const dndState:Readonly<DndState> = _dndState as Readonly<DndState>;\r\n","import {\r\n  AfterViewInit,\r\n  Directive,\r\n  ElementRef,\r\n  EventEmitter,\r\n  HostBinding,\r\n  HostListener,\r\n  Input,\r\n  NgZone,\r\n  OnDestroy,\r\n  Output,\r\n  Renderer2\r\n} from \"@angular/core\";\r\nimport { calculateDragImageOffset, DndDragImageOffsetFunction, DndEvent, setDragData, setDragImage } from \"./dnd-utils\";\r\nimport { DndHandleDirective } from \"./dnd-handle.directive\";\r\nimport { dndState, endDrag, startDrag } from \"./dnd-state\";\r\nimport { EffectAllowed } from \"./dnd-types\";\r\n\r\n@Directive( {\r\n  selector: \"[dndDragImageRef]\"\r\n} )\r\nexport class DndDragImageRefDirective {\r\n\r\n  constructor( parent:DndDraggableDirective,\r\n               elementRef:ElementRef ) {\r\n\r\n    parent.registerDragImage( elementRef );\r\n  }\r\n}\r\n\r\n@Directive( {\r\n  selector: \"[dndDraggable]\"\r\n} )\r\nexport class DndDraggableDirective implements AfterViewInit, OnDestroy {\r\n\r\n  @Input()\r\n  dndDraggable:any;\r\n\r\n  @Input()\r\n  dndEffectAllowed:EffectAllowed = \"copy\";\r\n\r\n  @Input()\r\n  dndType?:string;\r\n\r\n  @Input()\r\n  dndDraggingClass = \"dndDragging\";\r\n\r\n  @Input()\r\n  dndDraggingSourceClass = \"dndDraggingSource\";\r\n\r\n  @Input()\r\n  dndDraggableDisabledClass = \"dndDraggableDisabled\";\r\n\r\n  @Input()\r\n  dndDragImageOffsetFunction:DndDragImageOffsetFunction = calculateDragImageOffset;\r\n\r\n  @Output()\r\n  readonly dndStart:EventEmitter<DragEvent> = new EventEmitter<DragEvent>();\r\n\r\n  @Output()\r\n  readonly dndDrag:EventEmitter<DragEvent> = new EventEmitter<DragEvent>();\r\n\r\n  @Output()\r\n  readonly dndEnd:EventEmitter<DragEvent> = new EventEmitter<DragEvent>();\r\n\r\n  @Output()\r\n  readonly dndMoved:EventEmitter<DragEvent> = new EventEmitter<DragEvent>();\r\n\r\n  @Output()\r\n  readonly dndCopied:EventEmitter<DragEvent> = new EventEmitter<DragEvent>();\r\n\r\n  @Output()\r\n  readonly dndLinked:EventEmitter<DragEvent> = new EventEmitter<DragEvent>();\r\n\r\n  @Output()\r\n  readonly dndCanceled:EventEmitter<DragEvent> = new EventEmitter<DragEvent>();\r\n\r\n  @HostBinding( \"attr.draggable\" )\r\n  draggable = true;\r\n\r\n  private dndHandle?:DndHandleDirective;\r\n\r\n  private dndDragImageElementRef?:ElementRef;\r\n\r\n  private dragImage:Element;\r\n\r\n  private isDragStarted:boolean = false;\r\n\r\n  private readonly dragEventHandler:( event:DragEvent ) => void = ( event:DragEvent ) => this.onDrag( event );\r\n\r\n  @Input()\r\n  set dndDisableIf( value:boolean ) {\r\n\r\n    this.draggable = !value;\r\n\r\n    if( this.draggable ) {\r\n\r\n      this.renderer.removeClass( this.elementRef.nativeElement, this.dndDraggableDisabledClass );\r\n    }\r\n    else {\r\n\r\n      this.renderer.addClass( this.elementRef.nativeElement, this.dndDraggableDisabledClass );\r\n    }\r\n  }\r\n\r\n  @Input()\r\n  set dndDisableDragIf( value:boolean ) {\r\n    this.dndDisableIf = value;\r\n  }\r\n\r\n  constructor( private elementRef:ElementRef,\r\n               private renderer:Renderer2,\r\n               private ngZone:NgZone ) {\r\n  }\r\n\r\n  ngAfterViewInit():void {\r\n    this.ngZone.runOutsideAngular( () => {\r\n      this.elementRef.nativeElement.addEventListener( \"drag\", this.dragEventHandler );\r\n    } );\r\n  }\r\n\r\n  ngOnDestroy():void {\r\n    this.elementRef.nativeElement.removeEventListener( \"drag\", this.dragEventHandler );\r\n    if(this.isDragStarted === true) {\r\n      endDrag()\r\n    }\r\n  }\r\n\r\n  @HostListener( \"dragstart\", [ \"$event\" ] )\r\n  onDragStart( event:DndEvent ) {\r\n\r\n    if( this.draggable === false ) {\r\n\r\n      return false;\r\n    }\r\n\r\n    // check if there is dnd handle and if the dnd handle was used to start the drag\r\n    if( typeof this.dndHandle !== \"undefined\"\r\n      && typeof event._dndUsingHandle === \"undefined\" ) {\r\n\r\n      return false;\r\n    }\r\n\r\n    // initialize global state\r\n    startDrag( event, this.dndEffectAllowed, this.dndType );\r\n\r\n    this.isDragStarted = true;\r\n\r\n    setDragData( event, {data: this.dndDraggable, type: this.dndType}, dndState.effectAllowed );\r\n\r\n    this.dragImage = this.determineDragImage();\r\n\r\n    // set dragging css class prior to setDragImage so styles are applied before\r\n    // TODO breaking change: add class to elementRef rather than drag image which could be another element\r\n    this.renderer.addClass( this.dragImage, this.dndDraggingClass );\r\n\r\n    // set custom dragimage if present\r\n    // set dragimage if drag is started from dndHandle\r\n    if( typeof this.dndDragImageElementRef !== \"undefined\"\r\n      || typeof event._dndUsingHandle !== \"undefined\" ) {\r\n\r\n      setDragImage( event, this.dragImage, this.dndDragImageOffsetFunction );\r\n    }\r\n\r\n    // add dragging source css class on first drag event\r\n    const unregister = this.renderer.listen( this.elementRef.nativeElement, \"drag\", () => {\r\n\r\n      this.renderer.addClass( this.elementRef.nativeElement, this.dndDraggingSourceClass );\r\n      unregister();\r\n    } );\r\n\r\n    this.dndStart.emit( event );\r\n\r\n    // event.stopPropagation();\r\n  }\r\n\r\n  onDrag( event:DragEvent ) {\r\n\r\n    this.dndDrag.emit( event );\r\n  }\r\n\r\n  @HostListener( \"dragend\", [ \"$event\" ] )\r\n  onDragEnd( event:DragEvent ) {\r\n\r\n    // get drop effect from custom stored state as its not reliable across browsers\r\n    const dropEffect = dndState.dropEffect;\r\n\r\n    let dropEffectEmitter:EventEmitter<DragEvent>;\r\n\r\n    switch( dropEffect ) {\r\n\r\n      case \"copy\":\r\n        dropEffectEmitter = this.dndCopied;\r\n        break;\r\n\r\n      case \"link\":\r\n        dropEffectEmitter = this.dndLinked;\r\n        break;\r\n\r\n      case \"move\":\r\n        dropEffectEmitter = this.dndMoved;\r\n        break;\r\n\r\n      default:\r\n        dropEffectEmitter = this.dndCanceled;\r\n        break;\r\n    }\r\n\r\n    dropEffectEmitter.emit( event );\r\n    this.dndEnd.emit( event );\r\n\r\n    // reset global state\r\n    endDrag();\r\n\r\n    this.isDragStarted = false;\r\n\r\n    this.renderer.removeClass( this.dragImage, this.dndDraggingClass );\r\n\r\n    // IE9 special hammering\r\n    window.setTimeout( () => {\r\n      this.renderer.removeClass( this.elementRef.nativeElement, this.dndDraggingSourceClass );\r\n    }, 0 );\r\n\r\n    event.stopPropagation();\r\n  }\r\n\r\n  registerDragHandle( handle:DndHandleDirective | undefined ) {\r\n\r\n    this.dndHandle = handle;\r\n  }\r\n\r\n  registerDragImage( elementRef:ElementRef | undefined ) {\r\n\r\n    this.dndDragImageElementRef = elementRef;\r\n  }\r\n\r\n  private determineDragImage():Element {\r\n\r\n    // evaluate custom drag image existence\r\n    if( typeof this.dndDragImageElementRef !== \"undefined\" ) {\r\n\r\n      return this.dndDragImageElementRef.nativeElement as Element;\r\n    }\r\n    else {\r\n\r\n      return this.elementRef.nativeElement;\r\n    }\r\n  }\r\n}\r\n","import {\r\n  AfterViewInit,\r\n  ContentChild,\r\n  Directive,\r\n  ElementRef,\r\n  EventEmitter,\r\n  HostListener,\r\n  Input,\r\n  NgZone,\r\n  OnDestroy,\r\n  Output,\r\n  Renderer2\r\n} from \"@angular/core\";\r\nimport {\r\n  DndEvent,\r\n  DragDropData,\r\n  getDirectChildElement,\r\n  getDropData,\r\n  shouldPositionPlaceholderBeforeElement\r\n} from \"./dnd-utils\";\r\nimport { getDndType, getDropEffect, isExternalDrag, setDropEffect } from \"./dnd-state\";\r\nimport { DropEffect, EffectAllowed } from \"./dnd-types\";\r\n\r\nexport interface DndDropEvent {\r\n  event:DragEvent;\r\n  dropEffect:DropEffect;\r\n  isExternal:boolean;\r\n  data?:any;\r\n  index?:number;\r\n  type?:any;\r\n}\r\n\r\n@Directive( {\r\n  selector: \"[dndPlaceholderRef]\"\r\n} )\r\nexport class DndPlaceholderRefDirective {\r\n\r\n  constructor( public readonly elementRef:ElementRef ) {\r\n  }\r\n}\r\n\r\n@Directive( {\r\n  selector: \"[dndDropzone]\"\r\n} )\r\nexport class DndDropzoneDirective implements AfterViewInit, OnDestroy {\r\n\r\n  @Input()\r\n  dndDropzone?:string[];\r\n\r\n  @Input()\r\n  dndEffectAllowed:EffectAllowed;\r\n\r\n  @Input()\r\n  dndAllowExternal:boolean = false;\r\n\r\n  @Input()\r\n  dndHorizontal:boolean = false;\r\n\r\n  @Input()\r\n  dndDragoverClass:string = \"dndDragover\";\r\n\r\n  @Input()\r\n  dndDropzoneDisabledClass = \"dndDropzoneDisabled\";\r\n\r\n  @Output()\r\n  readonly dndDragover:EventEmitter<DragEvent> = new EventEmitter<DragEvent>();\r\n\r\n  @Output()\r\n  readonly dndDrop:EventEmitter<DndDropEvent> = new EventEmitter<DndDropEvent>();\r\n\r\n  @ContentChild( DndPlaceholderRefDirective )\r\n  private readonly dndPlaceholderRef?:DndPlaceholderRefDirective;\r\n\r\n  private placeholder:Element | null = null;\r\n\r\n  private disabled:boolean = false;\r\n\r\n  private readonly dragEnterEventHandler:( event:DragEvent ) => void = ( event:DragEvent ) => this.onDragEnter( event );\r\n  private readonly dragOverEventHandler:( event:DragEvent ) => void = ( event:DragEvent ) => this.onDragOver( event );\r\n  private readonly dragLeaveEventHandler:( event:DragEvent ) => void = ( event:DragEvent ) => this.onDragLeave( event );\r\n\r\n  @Input()\r\n  set dndDisableIf( value:boolean ) {\r\n\r\n    this.disabled = !!value;\r\n\r\n    if( this.disabled ) {\r\n\r\n      this.renderer.addClass( this.elementRef.nativeElement, this.dndDropzoneDisabledClass );\r\n    }\r\n    else {\r\n\r\n      this.renderer.removeClass( this.elementRef.nativeElement, this.dndDropzoneDisabledClass );\r\n    }\r\n  }\r\n\r\n  @Input()\r\n  set dndDisableDropIf( value:boolean ) {\r\n    this.dndDisableIf = value;\r\n  }\r\n\r\n  constructor( private ngZone:NgZone,\r\n               private elementRef:ElementRef,\r\n               private renderer:Renderer2 ) {\r\n  }\r\n\r\n  ngAfterViewInit():void {\r\n\r\n    this.placeholder = this.tryGetPlaceholder();\r\n\r\n    this.removePlaceholderFromDOM();\r\n\r\n    this.ngZone.runOutsideAngular( () => {\r\n      this.elementRef.nativeElement.addEventListener( \"dragenter\", this.dragEnterEventHandler );\r\n      this.elementRef.nativeElement.addEventListener( \"dragover\", this.dragOverEventHandler );\r\n      this.elementRef.nativeElement.addEventListener( \"dragleave\", this.dragLeaveEventHandler );\r\n    } );\r\n  }\r\n\r\n  ngOnDestroy():void {\r\n    this.elementRef.nativeElement.removeEventListener( \"dragenter\", this.dragEnterEventHandler );\r\n    this.elementRef.nativeElement.removeEventListener( \"dragover\", this.dragOverEventHandler );\r\n    this.elementRef.nativeElement.removeEventListener( \"dragleave\", this.dragLeaveEventHandler );\r\n  }\r\n\r\n  onDragEnter( event:DndEvent ) {\r\n\r\n    // check if another dropzone is activated\r\n    if( event._dndDropzoneActive === true ) {\r\n\r\n      this.cleanupDragoverState();\r\n      return;\r\n    }\r\n\r\n    // set as active if the target element is inside this dropzone\r\n    if( typeof event._dndDropzoneActive === \"undefined\" ) {\r\n\r\n      const newTarget = document.elementFromPoint( event.clientX, event.clientY );\r\n\r\n      if( this.elementRef.nativeElement.contains( newTarget ) ) {\r\n\r\n        event._dndDropzoneActive = true;\r\n      }\r\n    }\r\n\r\n    // check if this drag event is allowed to drop on this dropzone\r\n    const type = getDndType( event );\r\n    if( this.isDropAllowed( type ) === false ) {\r\n\r\n      return;\r\n    }\r\n\r\n    // allow the dragenter\r\n    event.preventDefault();\r\n  }\r\n\r\n  onDragOver( event:DragEvent ) {\r\n    // With nested dropzones, we want to ignore this event if a child dropzone\r\n    // has already handled a dragover.  Historically, event.stopPropagation() was\r\n    // used to prevent this bubbling, but that prevents any dragovers outside the\r\n    // ngx-drag-drop component, and stops other use cases such as scrolling on drag.\r\n    // Instead, we can check if the event was already prevented by a child and bail early.\r\n    if( event.defaultPrevented ) {\r\n\r\n      return;\r\n    }\r\n\r\n    // check if this drag event is allowed to drop on this dropzone\r\n    const type = getDndType( event );\r\n    if( this.isDropAllowed( type ) === false ) {\r\n\r\n      return;\r\n    }\r\n\r\n    this.checkAndUpdatePlaceholderPosition( event );\r\n\r\n    const dropEffect = getDropEffect( event, this.dndEffectAllowed );\r\n\r\n    if( dropEffect === \"none\" ) {\r\n\r\n      this.cleanupDragoverState();\r\n      return;\r\n    }\r\n\r\n    // allow the dragover\r\n    event.preventDefault();\r\n\r\n    // set the drop effect\r\n    setDropEffect( event, dropEffect );\r\n\r\n    this.dndDragover.emit( event );\r\n\r\n    this.renderer.addClass( this.elementRef.nativeElement, this.dndDragoverClass );\r\n  }\r\n\r\n  @HostListener( \"drop\", [ \"$event\" ] )\r\n  onDrop( event:DragEvent ) {\r\n\r\n    try {\r\n\r\n      // check if this drag event is allowed to drop on this dropzone\r\n      const type = getDndType( event );\r\n      if( this.isDropAllowed( type ) === false ) {\r\n\r\n        return;\r\n      }\r\n\r\n      const data:DragDropData = getDropData( event, isExternalDrag() );\r\n\r\n      if( this.isDropAllowed( data.type ) === false ) {\r\n\r\n        return;\r\n      }\r\n\r\n      // signal custom drop handling\r\n      event.preventDefault();\r\n\r\n      const dropEffect = getDropEffect( event );\r\n\r\n      setDropEffect( event, dropEffect );\r\n\r\n      if( dropEffect === \"none\" ) {\r\n\r\n        return;\r\n      }\r\n\r\n      const dropIndex = this.getPlaceholderIndex();\r\n\r\n      // if for whatever reason the placeholder is not present in the DOM but it should be there\r\n      // we don't allow/emit the drop event since it breaks the contract\r\n      // seems to only happen if drag and drop is executed faster than the DOM updates\r\n      if( dropIndex === -1 ) {\r\n\r\n        return;\r\n      }\r\n\r\n      this.dndDrop.emit( {\r\n        event: event,\r\n        dropEffect: dropEffect,\r\n        isExternal: isExternalDrag(),\r\n        data: data.data,\r\n        index: dropIndex,\r\n        type: type,\r\n      } );\r\n\r\n      event.stopPropagation();\r\n\r\n    }\r\n    finally {\r\n\r\n      this.cleanupDragoverState();\r\n    }\r\n  }\r\n\r\n  onDragLeave( event:DndEvent ) {\r\n\r\n    // check if still inside this dropzone and not yet handled by another dropzone\r\n    if( typeof event._dndDropzoneActive === \"undefined\" ) {\r\n\r\n      const newTarget = document.elementFromPoint( event.clientX, event.clientY );\r\n\r\n      if( this.elementRef.nativeElement.contains( newTarget ) ) {\r\n\r\n        event._dndDropzoneActive = true;\r\n        return;\r\n      }\r\n    }\r\n\r\n    this.cleanupDragoverState();\r\n\r\n    // cleanup drop effect when leaving dropzone\r\n    setDropEffect( event, \"none\" );\r\n  }\r\n\r\n  private isDropAllowed( type?:string ):boolean {\r\n\r\n    // dropzone is disabled -> deny it\r\n    if( this.disabled === true ) {\r\n\r\n      return false;\r\n    }\r\n\r\n    // if drag did not start from our directive\r\n    // and external drag sources are not allowed -> deny it\r\n    if( isExternalDrag() === true\r\n      && this.dndAllowExternal === false ) {\r\n\r\n      return false;\r\n    }\r\n\r\n    // no filtering by types -> allow it\r\n    if( !this.dndDropzone ) {\r\n\r\n      return true;\r\n    }\r\n\r\n    // no type set -> allow it\r\n    if( !type ) {\r\n\r\n      return true;\r\n    }\r\n\r\n    if( Array.isArray( this.dndDropzone ) === false ) {\r\n\r\n      throw new Error( \"dndDropzone: bound value to [dndDropzone] must be an array!\" );\r\n    }\r\n\r\n    // if dropzone contains type -> allow it\r\n    return this.dndDropzone.indexOf( type ) !== -1;\r\n  }\r\n\r\n  private tryGetPlaceholder():Element | null {\r\n\r\n    if( typeof this.dndPlaceholderRef !== \"undefined\" ) {\r\n\r\n      return this.dndPlaceholderRef.elementRef.nativeElement as Element;\r\n    }\r\n\r\n    // TODO nasty workaround needed because if ng-container / template is used @ContentChild() or DI will fail because\r\n    // of wrong context see angular bug https://github.com/angular/angular/issues/13517\r\n    return this.elementRef.nativeElement.querySelector( \"[dndPlaceholderRef]\" );\r\n  }\r\n\r\n  private removePlaceholderFromDOM() {\r\n\r\n    if( this.placeholder !== null\r\n      && this.placeholder.parentNode !== null ) {\r\n      this.placeholder.parentNode.removeChild( this.placeholder );\r\n    }\r\n  }\r\n\r\n  private checkAndUpdatePlaceholderPosition( event:DragEvent ):void {\r\n\r\n    if( this.placeholder === null ) {\r\n\r\n      return;\r\n    }\r\n\r\n    // make sure the placeholder is in the DOM\r\n    if( this.placeholder.parentNode !== this.elementRef.nativeElement ) {\r\n\r\n      this.renderer.appendChild( this.elementRef.nativeElement, this.placeholder );\r\n    }\r\n\r\n    // update the position if the event originates from a child element of the dropzone\r\n    const directChild = getDirectChildElement( this.elementRef.nativeElement, event.target as Element );\r\n\r\n    // early exit if no direct child or direct child is placeholder\r\n    if( directChild === null\r\n      || directChild === this.placeholder ) {\r\n\r\n      return;\r\n    }\r\n\r\n    const positionPlaceholderBeforeDirectChild = shouldPositionPlaceholderBeforeElement( event, directChild, this.dndHorizontal );\r\n\r\n    if( positionPlaceholderBeforeDirectChild ) {\r\n\r\n      // do insert before only if necessary\r\n      if( directChild.previousSibling !== this.placeholder ) {\r\n\r\n        this.renderer.insertBefore( this.elementRef.nativeElement, this.placeholder, directChild );\r\n      }\r\n    }\r\n    else {\r\n\r\n      // do insert after only if necessary\r\n      if( directChild.nextSibling !== this.placeholder ) {\r\n\r\n        this.renderer.insertBefore( this.elementRef.nativeElement, this.placeholder, directChild.nextSibling );\r\n      }\r\n    }\r\n  }\r\n\r\n  private getPlaceholderIndex():number | undefined {\r\n\r\n    if( this.placeholder === null ) {\r\n\r\n      return undefined;\r\n    }\r\n\r\n    const element = this.elementRef.nativeElement as HTMLElement;\r\n\r\n    return Array.prototype.indexOf.call( element.children, this.placeholder );\r\n  }\r\n\r\n  private cleanupDragoverState() {\r\n\r\n    this.renderer.removeClass( this.elementRef.nativeElement, this.dndDragoverClass );\r\n\r\n    this.removePlaceholderFromDOM();\r\n  }\r\n}\r\n","import { Directive, HostBinding, HostListener } from \"@angular/core\";\r\nimport { DndEvent } from \"./dnd-utils\";\r\nimport { DndDraggableDirective } from \"./dnd-draggable.directive\";\r\n\r\n@Directive( {\r\n  selector: \"[dndHandle]\"\r\n} )\r\nexport class DndHandleDirective {\r\n\r\n  @HostBinding( \"attr.draggable\" )\r\n  draggable = true;\r\n\r\n  constructor( parent:DndDraggableDirective ) {\r\n\r\n    parent.registerDragHandle( this );\r\n  }\r\n\r\n  @HostListener( \"dragstart\", [ \"$event\" ] )\r\n  @HostListener( \"dragend\", [ \"$event\" ] )\r\n  onDragEvent( event:DndEvent ) {\r\n\r\n    event._dndUsingHandle = true;\r\n  }\r\n}\r\n","import { NgModule } from \"@angular/core\";\r\nimport { CommonModule } from \"@angular/common\";\r\nimport { DndDraggableDirective, DndDragImageRefDirective } from \"./dnd-draggable.directive\";\r\nimport { DndDropzoneDirective, DndPlaceholderRefDirective } from \"./dnd-dropzone.directive\";\r\nimport { DndHandleDirective } from \"./dnd-handle.directive\";\r\n\r\n@NgModule( {\r\n  imports: [\r\n    CommonModule\r\n  ],\r\n  declarations: [\r\n    DndDraggableDirective,\r\n    DndDropzoneDirective,\r\n    DndHandleDirective,\r\n    DndPlaceholderRefDirective,\r\n    DndDragImageRefDirective\r\n  ],\r\n  exports: [\r\n    DndDraggableDirective,\r\n    DndDropzoneDirective,\r\n    DndHandleDirective,\r\n    DndPlaceholderRefDirective,\r\n    DndDragImageRefDirective\r\n  ]\r\n} )\r\nexport class DndModule {\r\n}\r\n"]}